---
title: "Structuring a SimPy model"
---

There are many different ways to structure a SimPy model. This page runs through some options - but first runs through the basics of how SimPy works.

```{python}
import numpy as np
import simpy
```

## Context: Python components

::: {.callout-note icon=false collapse="true"}

## Generator functions

**Normal functions** use `return` to output a value and terminate.

```{python}
# Normal function
def normal_example():
    return ["a", "b", "c"]

# Calling the normal function
print(normal_example())
```

**Generator functions** use `yield` to output a value and pause execution. They create and return an iterator object, with local variables and states retained between successive calls. They can support multiple yield statements.

```{python}
# Generator function
def generator_example(): 
    yield "a"
    yield "b"
    yield "c"

# Generator object
x = generator_example()
print(x)

# Iterating over the generator object using "next()"
print(next(x))  # Output: "a"
print(next(x))  # Output: "b"
print(next(x))  # Output: "c"
```

:::

::: {.callout-note icon=false collapse="true"}

## Classes

There are two ways to programme in python:

(1) **Functional** - write functions, best when:

* Task is straightforward with a single purpose
* Task doesn't maintain/share data between calls

```{python}
# Function to calculate the square of a number
def square(num):
    return num * num

# Calling the function
result = square(4)
print(result)  # Output: 16
```

(2) **Object oriented** - create classes with attributes and methods, best when:

* Want to maintain/store data between methods or class
* Want to group related data (attributes) and methods together
* Want to create multiple objects that share the same behaviour but have different data

```{python}
# Class representing a simple calculator
class Calculator:
    def __init__(self):  # Constructor to initialize the object
        self.result = 0
    
    def add(self, value):
        self.result += value
    
    def subtract(self, value):
        self.result -= value

# Creating an object of the Calculator class
calc = Calculator()
calc.add(10)
calc.subtract(3)
print(calc.result)  # Output: 7
```

:::

## How SimPy works

Active components (e.g. patients) are modelled using **processes**. They create **events** and `yield` them to wait for them to occur, and so are defined by python generator functions. Events include:

* **Timeouts** - simulate time passing, e.g. `yield env.timeout(inter_arrival_time)`
* **Requests and releases** - interacting with resource, e.g. `server_pool.request()`

This all happens within an **environment** (`simpy.Environment()`) which manages time and processes, is required to create new events.

For more information, see the SimPy documentation: <https://simpy.readthedocs.io>

## Functions v.s. classes

Whilst it is possible to write a SimPy model using functions, classes are recommended as they:

* Have internal state (with attributes)
* Have their own functions

This is handy when we have, for example, patient attributes and abilities to group together.

However, some examples of a SimPy M/M/c model without classes are provided:

::: {.callout-note icon=false collapse="true"}

## Example 1: Single function

```{python}
# Parameters
iat = 15  # Inter-arrival time (mean time between arrivals)
dur = 10  # Average service duration (mean service time)
servers = 3  # Number of servers
run_length = 200  # Total simulation time

# Produce seeds which we use to initialise seperate RNGs for sampling from each
# distribution with independent random number streams
entropy = 12345
ss = np.random.SeedSequence(entropy)
seeds = ss.spawn(2)
arrivals_rng = np.random.default_rng(seeds[0])
duration_rng = np.random.default_rng(seeds[1])

# Lists to store wait times and service times
wait_times = []
service_times = []


def model(env, arrival_rate, dur, servers):
    '''
    Simulates a system where patients arrive randomly and require service from
    a limited number of servers. Tracks wait times and service durations during
    the simulation.

    Parameters
    ----------
    env : simpy.Environment
        The SimPy environment instance.
    arrival_rate : numeric
        Mean inter-arrival time for patients.
    dur: numeric
        Mean service time.
    servers : int
        The number of servers available to handle the patients.
    '''
    while True:
        # Create server SimPy resource
        server_pool = simpy.Resource(env, capacity=servers)

        # Get time until next arrival by sampling from exponential distribution
        inter_arrival_time = arrivals_rng.exponential(arrival_rate)
        yield env.timeout(inter_arrival_time)

        # Request a server and record wait time
        with server_pool.request() as request:
            wait_start_time = env.now
            yield request
            wait_time = env.now - wait_start_time
            wait_times.append(wait_time)

            # Get service time by sampling from exponential distribution
            service_time = duration_rng.exponential(dur)
            service_times.append(service_time)
            yield env.timeout(service_time)

# Set up the simulation environment
env = simpy.Environment()
# Start the arrival process and run for specified period of time
env.process(model(env, iat, dur))
env.run(until=run_length)

# After the simulation ends, calculate average wait time and service time
average_wait_time = np.mean(wait_times)
average_service_time = np.mean(service_times)
print(f'\nAverage wait time: {average_wait_time:.2f}')
print(f'Average service time: {average_service_time:.2f}')
```

:::

::: {.callout-note icon=false collapse="true"}

## Example 2: Multiple functions

```{python}
# Parameters
iat = 15  # Inter-arrival time (mean time between arrivals)
dur = 10  # Average service duration (mean service time)
servers = 3  # Number of servers
run_length = 200  # Total simulation time

# Produce seeds which we use to initialise seperate RNGs for sampling from each
# distribution with independent random number streams
entropy = 12345
ss = np.random.SeedSequence(entropy)
seeds = ss.spawn(2)
arrivals_rng = np.random.default_rng(seeds[0])
duration_rng = np.random.default_rng(seeds[1])

# Lists to store wait times and service times
wait_times = []
service_times = []


def patient(env, server_pool):
    '''
    Simulate the behavior of a single patient in the system.

    Parameters
    ----------
    env : simpy.Environment
        The SimPy environment instance.
    server_pool : simpy.Resource
        The SimPy resource pool representing the servers.
    '''

    # Request a server and record wait time
    with server_pool.request() as request:
        wait_start_time = env.now
        yield request
        wait_time = env.now - wait_start_time
        wait_times.append(wait_time)

        # Get service time by sampling from exponential distribution
        service_time = duration_rng.exponential(dur)
        service_times.append(service_time)
        yield env.timeout(service_time)


def setup(env, arrival_rate, server_pool):
    '''
    Simulate the arrival of patients to the system.

    Patients arrive at intervals determined by an exponential distribution,
    and each patient triggers the patient process.

    Parameters
    ----------
    env : simpy.Environment
        The SimPy environment instance.
    arrival_rate : float
        The mean inter-arrival time for patients.
    server_pool : simpy.Resource
        The SimPy resource pool representing the servers.
    '''

    while True:

        # Get time until next arrival by sampling from exponential distribution
        inter_arrival_time = arrivals_rng.exponential(iat)
        yield env.timeout(inter_arrival_time)

        # Create new patient and start the patient process
        env.process(patient(env, server_pool))


# Set up simulation environment
env = simpy.Environment()

# Create server SimPy resource
server_pool = simpy.Resource(env, capacity=servers)

# Start the arrival process and run for specified period of time
env.process(setup(env, iat, server_pool))
env.run(until=run_length)

# After the simulation ends, calculate average wait time and service time
average_wait_time = np.mean(wait_times)
average_service_time = np.mean(service_times)
print(f'\nAverage wait time: {average_wait_time:.2f}')
print(f'Average service time: {average_service_time:.2f}')
```

:::

## Classes

```{python}
import numpy as np
import simpy

class HospitalSimulation:
    def __init__(self, iat, dur, servers, run_length, entropy=12345):
        '''
        Initialize the simulation parameters.

        Parameters
        ----------
        iat : float
            Inter-arrival time (mean time between arrivals).
        dur : float
            Average service duration (mean service time).
        servers : int
            Number of servers.
        run_length : float
            Total simulation time.
        entropy : int, optional
            Seed for random number generation, by default 12345.
        '''
        self.iat = iat
        self.dur = dur
        self.servers = servers
        self.run_length = run_length

        # Produce seeds for independent RNGs for arrival and service time distributions
        ss = np.random.SeedSequence(entropy)
        seeds = ss.spawn(2)
        self.arrivals_rng = np.random.default_rng(seeds[0])
        self.duration_rng = np.random.default_rng(seeds[1])

        # Lists to store wait times and service times
        self.wait_times = []
        self.service_times = []

    def patient(self, env, server_pool):
        '''
        Simulate the behavior of a single patient in the system.

        Parameters
        ----------
        env : simpy.Environment
            The SimPy environment instance.
        server_pool : simpy.Resource
            The SimPy resource pool representing the servers.
        '''
        # Request a server and record wait time
        with server_pool.request() as request:
            wait_start_time = env.now
            yield request
            wait_time = env.now - wait_start_time
            self.wait_times.append(wait_time)

            # Get service time by sampling from exponential distribution
            service_time = self.duration_rng.exponential(self.dur)
            self.service_times.append(service_time)
            yield env.timeout(service_time)

    def setup(self, env, server_pool):
        '''
        Simulate the arrival of patients to the system.

        Parameters
        ----------
        env : simpy.Environment
            The SimPy environment instance.
        server_pool : simpy.Resource
            The SimPy resource pool representing the servers.
        '''
        while True:
            # Get time until next arrival by sampling from exponential distribution
            inter_arrival_time = self.arrivals_rng.exponential(self.iat)
            yield env.timeout(inter_arrival_time)

            # Create a new patient and start the patient process
            env.process(self.patient(env, server_pool))

    def run(self):
        '''
        Run the simulation.
        '''
        # Set up simulation environment
        env = simpy.Environment()

        # Create server SimPy resource
        server_pool = simpy.Resource(env, capacity=self.servers)

        # Start the arrival process and run for the specified period of time
        env.process(self.setup(env, server_pool))
        env.run(until=self.run_length)

        # After the simulation ends, calculate average wait time and service time
        average_wait_time = np.mean(self.wait_times) if self.wait_times else 0
        average_service_time = np.mean(self.service_times) if self.service_times else 0
        print(f'\nAverage wait time: {average_wait_time:.2f}')
        print(f'Average service time: {average_service_time:.2f}')


# Parameters
iat = 15  # Inter-arrival time (mean time between arrivals)
dur = 10  # Average service duration (mean service time)
servers = 3  # Number of servers
run_length = 200  # Total simulation time

# Create the simulation instance and run it
simulation = HospitalSimulation(iat, dur, servers, run_length)
simulation.run()
```
