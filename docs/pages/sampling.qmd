---
title: "Sampling"
---

```{python}
import numpy as np
import random
import simpy
```

## Pseudorandom number generation

A **random number generator (RNG)** is a system generating random numbers from a true source of randomness (e.g. electrostatic noise converted into random numbers). However, we donâ€™t need true randomness, so we use a **pseudorandom number generator (PRNG)**.

A PRNG is also known as a **deterministic** random bit generator (DRBG). It generates a sequence of numbers that look close to random - but are not truly random, since it is determined by an intial value called the **seed**.

<https://machinelearningmastery.com/how-to-generate-random-numbers-in-python/>

<https://en.wikipedia.org/wiki/Pseudorandom_number_generator>

The `numpy.random` module is recommended over the built-in `random` module for pseudorandom number generation in python as it:

* Generates large samples of random numbers (whilst `random` can only generate one at a time).
* Has quicker performance when generating large samples.

::: {.callout-note appearance="minimal" collapse="true"}

## Basic example

<!-- Perhaps remove this, just stick with numpy example -->

Using `random`:

```{python}
[random.expovariate(lambd=2) for _ in range(5)]
```

Using `numpy`:

```{python}
np.random.exponential(scale=2, size=5)
```

:::

<https://wesmckinney.com/book/numpy-basics.html#numpy_random>

## Recommended method

```{python}
# Parameters: inter-arrival rate and average service duration
iat = 15
dur = 10

# This is essentially our "starter seed"
entropy = 12345

# Generate 10 seeds which will create independent streams
ss = np.random.SeedSequence(entropy)
seeds = ss.spawn(10)

# Initialise RNGs with independent seeds
rng = np.random.default_rng(seeds[0])
rng1 = np.random.default_rng(seeds[1])

rng.exponential(scale=iat, size=1)
rng1.exponential(scale=dur, size=1)
```

### Using generators

The NumPy RNG policy recommends using a generator object with a seed and passing that around, via `np.random.default_rng()`.

This is as opposed to using a "global" RNG. This is when you set a single seed at the start of the script using `np.random.seed()`. It is considered bad practice - global variables like a global RNG are not recommended as they can have influences throughout the script. You could change the variable for one part of the script and inadvertently impact elsewhere in the script - such as in the case of random numbers, where you could unknowingly reset the seed elsewhere in the codebase.

```{python}
# Sampling with global seed
np.random.seed(seed=5)
np.random.random(size=5)

# Sampling with generator object
rng = np.random.default_rng(seed=5)
rng.random(size=3)
```

<https://albertcthomas.github.io/good-practices-random-number-generators/>

### Individual random number streams

We gave each distribution it's own random number stream.

Why do we do that?

Illustrative example: First, if we use the same random number generator for both distributions, and run two scenarios: one with five arrivals, and one with two.

You'll see that we get different sampled values for the length of stay - which is a problem, as we could attribute improvement or worsening to the scenario (reducing arrivals), when actually it was due to sampling variation.

```{python}
# Single random number generator
rng = np.random.default_rng(seeds[0])

# Generate five samples for arrivals and length of stay
print('Sampling five from each...')
print(rng.exponential(scale=iat, size=5))
print(rng.exponential(scale=iat, size=5))

# Generate two samples for arrivals and length of stay
print('Sampling two from each...')
print(rng.exponential(scale=iat, size=2))
print(rng.exponential(scale=iat, size=2))
```

<https://www.pythonhealthdatascience.com/content/01_algorithms/03_numpy/06_sampling.html>

### SeedSequence

When creating each stream, have used seeds generated by `SeedSequence`. This is because it makes sure:

* Seeds likely have different initial states for RNG
* Streams are likely independent of each other

These are desirable properties, which we can't guarantee if we had just chosen a set of seeds for each ourselves. When using SeedSequence, we provide our own "starter seed" which can just be any number, and it will use that to generate seeds to use when setting up RNGs.

```{python}
# Choosing own seeds
rng = np.random.default_rng(seed=30)
rng1 = np.random.default_rng(seed=40)

# Using SeedStream
ss = np.random.SeedSequence(entropy=42)
seeds = ss.spawn(10)
rng = np.random.default_rng(seeds[0])
rng1 = np.random.default_rng(seeds[1])
```

<https://numpy.org/doc/1.18/reference/random/parallel.html#seedsequence-spawning>

### Optional extra: classes

If you make a class, it means you wouldn't have to redefine mean and appropriate stream every time you use the distribution.

```{python}
class Exponential:
    def __init__(self, mean, random_seed=None):
        self.rand = np.random.default_rng(seed=random_seed)
        self.mean = mean
        
    def sample(self, size=None):
        return self.rand.exponential(self.mean, size=size)


# Generate sample
arrivals = Exponential(mean=iat)
arrivals.sample(1)

los = Exponential(mean=dur)
los.sample(1)
```
